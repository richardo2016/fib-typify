#!/usr/bin/env fibjs

const fs = require('fs')
const path = require('path')
const util = require('util')

const argFlags = require('./utils/arg_flags')
const errCode = require('./utils/err_code')

const extendCompilerConfigFromTSConfig= require('../core/_utils').extendCompilerConfigFromTSConfig
const { compileDirectoryTo } = require('../core/fs-directory')
const defaultCompilerOptions = require('../core/_utils').defaultCompilerOptions
const typify = require('../lib')

is_debug() && console.log(process.argv)

function mergeCompilerConfigFromCustomConfig (configFilepath = null, origConfig = {}) {
    configFilepath = configFilepath ? path.resolve(cwd, configFilepath) : null

    if (configFilepath && fs.exists(configFilepath)) {
        let config = {}
        if (['.json', '.js', '.jsc'].some(ext => configFilepath.endsWith(ext))) {
            config = require(configFilepath)
            is_debug() && console.log('internal extension', config)
        } else {
            try {
                config = JSON.parse(fs.readTextFile(configFilepath))
            } catch (e) {
                console.warn(`error occured when trying to parse config file: ${configFilepath}`)
            }
        }

        origConfig = util.extend({}, origConfig, config)
    }
    return origConfig
}

function getParamFromArgs (args = [], optFlags = []) {
    if (!Array.isArray(optFlags)) {
        optFlags = [optFlags]
    }
    is_debug() && console.log('optFlags', optFlags, args)

    const argIndex = args.findIndex(x => optFlags.includes(x))
    return argIndex >= 0 ? args[argIndex + 1] : null
}

function isEntryExists (vbox, entryPoint) {
    // always allow existed file
    if (fs.exists(entryPoint)) return true;

    let existed = false
    try {
        vbox.resolve(entryPoint, __dirname)
        existed = true
    } catch (e) {
        existed = false
    }
    return existed
}

function main () {
    let tsCompilerOptions = JSON.parse(JSON.stringify(defaultCompilerOptions))

    const cwd = process.cwd()
    is_debug() && console.log('cwd', cwd)

    const [
        _1, _2,
        srcpath,
        ...args
    ] = process.argv || []

    // finalParams
    const fP = {
        cwd,
        srcpath,
        entryPoint: path.resolve(cwd, srcpath)
    }

    /* collect params :start */

    tsCompilerOptions = mergeCompilerConfigFromCustomConfig(getParamFromArgs(args, ['-c', '--config-file']), tsCompilerOptions)
    tsCompilerOptions = extendCompilerConfigFromTSConfig(tsCompilerOptions)
    /* collect params :end */

    tsCompilerOptions.outDir = tsCompilerOptions.outDir || getParamFromArgs(args, argFlags.output)
    is_debug() && console.log('tsCompilerOptions.outDir', tsCompilerOptions.outDir)

    const topTsSandbox = typify.loader({ compilerOptions: tsCompilerOptions }).sandbox()

    if (tsCompilerOptions.outDir) {
        /* run :start */
        const baseDir = path.resolve(fP.cwd, fP.srcpath)
        const distDir = path.resolve(fP.cwd, tsCompilerOptions.outDir)

        is_debug() && console.log('finalParams', fP)
        is_debug() && console.log('tsCompilerOptions', tsCompilerOptions);

        compileDirectoryTo(baseDir, distDir, {
            compilerOptions: tsCompilerOptions
        })
        /* run :end */
    } else if (isEntryExists(topTsSandbox, fP.entryPoint)) {
        topTsSandbox.require(fP.entryPoint, __dirname)
    } else {
        console.error(errCode["noArg:output"])
        process.exit(-1)
    }
}

function is_debug () {
    return !!process.env.FIB_TYPIFY_DEBUG
}

main()
