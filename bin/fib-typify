#!/usr/bin/env fibjs

const fs = require('fs')
const path = require('path')
const util = require('util')

const argFlags = require('./utils/arg_flags')
const errCode = require('./utils/err_code')

const extendCompilerConfigFromTSConfig = require('../core/_utils').extendCompilerConfigFromTSConfig
const replaceSuffix = require('../core/_utils').replaceSuffix

const { compileDirectoryTo } = require('../core/fs-directory')
const { generateLoaderbox } = require('../core/loader-box')

const defaultCompilerOptions = require('../core/_utils').defaultCompilerOptions

is_debug() && console.log('process.argv', process.argv)

function mergeCompilerConfigFromCustomConfig (configFilepath = null, origConfig = {}) {
    configFilepath = configFilepath ? path.resolve(cwd, configFilepath) : null

    if (configFilepath && fs.exists(configFilepath)) {
        let config = {}
        if (['.json', '.js', '.jsc'].some(ext => configFilepath.endsWith(ext))) {
            config = require(configFilepath)
            is_debug() && console.log('internal extension', config)
        } else {
            try {
                config = JSON.parse(fs.readTextFile(configFilepath))
            } catch (e) {
                console.warn(`error occured when trying to parse config file: ${configFilepath}`)
            }
        }

        origConfig = util.extend({}, origConfig, config)
    }
    return origConfig
}

function getArgIdxFromArgs (args = [], optFlags = []) {
    if (!Array.isArray(optFlags)) {
        optFlags = [optFlags]
    }
    is_debug() && console.log('optFlags', optFlags, args)

    const argIndex = args.findIndex(x => optFlags.includes(x))
    return argIndex
}

function getParamFromArgs (args = [], optFlags = []) {
    const argIndex = getArgIdxFromArgs(args, optFlags)
    return argIndex >= 0 ? args[argIndex + 1] : null
}

function resolveExistedEntry (vbox, entryPoint, cwd = __dirname) {
    // always allow existed file

    if (entryPoint && fs.exists(entryPoint) && fs.stat(entryPoint).isFile())
        return vbox.resolve(entryPoint, cwd);

    let existed = false
    try {
        vbox.resolve(entryPoint, cwd)
        existed = true
    } catch (e) {
        existed = false
    }
    return existed
}

function main () {
    let tsCompilerOptions = JSON.parse(JSON.stringify(defaultCompilerOptions))

    const cwd = process.cwd()
    is_debug() && console.log('cwd', cwd)

    const [
        _1, _2,
        srcpath,
        ...args
    ] = process.argv || []

    const outputValue = getParamFromArgs(args, argFlags.output)
    const outputExisted = getArgIdxFromArgs(args, argFlags.output) > -1

    /* collect params :start */
    tsCompilerOptions = mergeCompilerConfigFromCustomConfig(getParamFromArgs(args, ['-c', '--config-file']), tsCompilerOptions)
    tsCompilerOptions = extendCompilerConfigFromTSConfig(tsCompilerOptions)
    tsCompilerOptions.outDir = tsCompilerOptions.outDir || outputValue
    is_debug() && console.log('tsCompilerOptions', tsCompilerOptions);
    /* collect params :end */

    const topTsSandbox = generateLoaderbox(tsCompilerOptions)
    is_debug() && console.log('tsCompilerOptions.outDir', tsCompilerOptions.outDir)

    // finalParams
    const fP = {
        cwd,
        srcpath,
        entryPoint: resolveExistedEntry(topTsSandbox, srcpath, cwd)
    }
    is_debug() && console.log('finalParams', fP)

    if (outputExisted) {
        const baseDir = path.resolve(fP.cwd, fP.srcpath)
        const distDir = path.resolve(fP.cwd, outputValue || replaceSuffix(fP.srcpath, '.ts', '.js'))

        if (!fs.exists(baseDir)) {
            quit(errCode["invalidArg:input"])
        }

        compileDirectoryTo(baseDir, distDir, { compilerOptions: tsCompilerOptions })
    } else if (fP.entryPoint) {
        topTsSandbox.require(fP.entryPoint, __dirname)
    } else {
        quit(errCode["noArg:output"])
    }
}

function is_debug () {
    return !!process.env.FIB_TYPIFY_DEBUG
}

function quit (error_msg, code = -1) {
    console.error(error_msg)
    process.exit(-1)
}

main()
